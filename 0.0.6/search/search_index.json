{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"dovwms","text":"<p>Simple client for DOV WMS services.</p> <p>Lightweight Python client to fetch soil texture and elevation data from Belgian WMS services (DOV and Geopunt). The package provides convenience clients for the two services and a small helper to fetch a soil profile at a point location.</p> <ul> <li>Repository: https://github.com/zawadzkim/dovwms/</li> <li>Docs: https://zawadzkim.github.io/dovwms/</li> </ul>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Fetch clay/silt/sand fractions for standard depth layers from DOV WMS</li> <li>Fetch elevation from Geopunt WMS</li> <li>Small, testable API with helpers for convenience and easy mocking</li> </ul>"},{"location":"index.html#installation","title":"Installation","text":"<p>Requires Python 3.11+. Install from PyPI (when released):</p> <pre><code>pip install dovwms\n</code></pre> <p>For development from source (recommended):</p> <pre><code>git clone git@github.com:zawadzkim/dovwms.git\ncd dovwms\nmake install   # installs dev dependencies (uses poetry or pip in Makefile)\n</code></pre> <p>You can also install the package in editable mode:</p> <pre><code>python -m pip install -e .\n</code></pre>"},{"location":"index.html#quickstart","title":"Quickstart","text":"<p>Simple usage with the convenience function:</p> <pre><code>from dovwms import get_profile_from_dov\n\n# Coordinates in the default CRS (EPSG:31370 / Lambert72)\nprofile = get_profile_from_dov(247172.56, 204590.58, fetch_elevation=True)\n\nif profile is None:\n    print(\"Could not fetch profile\")\nelse:\n    # profile is a dict with keys 'layers' (list) and optional 'elevation'\n    print(\"Elevation:\", profile.get('elevation'))\n    for layer in profile['layers']:\n        print(layer['name'], layer['sand_content'], layer['silt_content'], layer['clay_content'])\n</code></pre> <p>Using the low-level clients:</p> <pre><code>from dovwms import DOVClient, GeopuntClient\nfrom shapely.geometry import Point\n\nclient = DOVClient()\npt = Point(247172.56, 204590.58)\n\n# Fetch texture layers\nprofile = client.fetch_profile(pt, fetch_elevation=False)\n\n# Fetch elevation directly\ng = GeopuntClient()\nelev = g.fetch_elevation(pt)\n</code></pre> <p>Notes</p> <ul> <li><code>fetch_profile</code> returns a dict with a <code>layers</code> key (list of layer dicts).</li> <li>Use the module-level loggers to enable/inspect runtime information; the   library does not configure logging handlers by default.</li> </ul>"},{"location":"index.html#testing","title":"Testing","text":"<p>Run the test suite with pytest (excl. integration tests). Development dependencies include pytest.</p> <pre><code>make test\n</code></pre> <p>Integration tests that require network access are marked <code>integration</code> and can be executed explicitly:</p> <pre><code>pytest -q -m integration\n</code></pre>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>Contributions are welcome. Please open issues or pull requests. Follow the project's code style and run tests before submitting changes.</p>"},{"location":"index.html#license","title":"License","text":"<p>MIT</p> <p>Repository scaffolded from fpgmaas/cookiecutter-poetry.</p> <p>Hopefully this is useful. Hopefully this package will expand, perhaps also include some more Geoupunt endpoints. Thanks for using dovwms! Documenting the changes.</p>"},{"location":"contributing.html","title":"Contributing","text":""},{"location":"contributing.html#contributing-to-dovwms","title":"Contributing to <code>dovwms</code>","text":"<p>!!! note</p> <p>this section requiers some adjustments.</p> <p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing.html#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing.html#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/zawadzkim/dovwms/issues</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing.html#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement a fix for it.</p>"},{"location":"contributing.html#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing.html#write-documentation","title":"Write Documentation","text":"<p>Cookiecutter PyPackage could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing.html#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/zawadzkim/dovwms/issues.</p> <p>If you are proposing a new feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing.html#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>dovwms</code> for local development. Please note this documentation assumes you already have <code>poetry</code> and <code>Git</code> installed and ready to go.</p> <ol> <li> <p>Fork the <code>dovwms</code> repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> </li> </ol> <pre><code>cd &lt;directory_in_which_repo_should_be_created&gt;\ngit clone git@github.com:YOUR_NAME/dovwms.git\n</code></pre> <ol> <li>Now we need to install the environment. Navigate into the directory</li> </ol> <pre><code>cd dovwms\n</code></pre> <p>If you are using <code>pyenv</code>, select a version to use locally. (See installed versions with <code>pyenv versions</code>)</p> <pre><code>pyenv local &lt;x.y.z&gt;\n</code></pre> <p>Then, install and activate the environment with:</p> <pre><code>poetry install\npoetry shell\n</code></pre> <ol> <li>Install pre-commit to run linters/formatters at commit time:</li> </ol> <pre><code>poetry run pre-commit install\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li> <p>Don't forget to add test cases for your added functionality to the <code>tests</code> directory.</p> </li> <li> <p>When you're done making changes, check that your changes pass the formatting tests.</p> </li> </ol> <pre><code>make check\n</code></pre> <p>Now, validate that all unit tests are passing:</p> <pre><code>make test\n</code></pre> <ol> <li>Before raising a pull request you should also run tox.    This will run the tests across different versions of Python:</li> </ol> <pre><code>tox\n</code></pre> <p>This requires you to have multiple versions of python installed. This step is also triggered in the CI/CD pipeline, so you could also choose to skip this step locally.</p> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing.html#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li> <p>The pull request should include tests.</p> </li> <li> <p>If the pull request adds functionality, the docs should be updated.    Put your new functionality into a function with a docstring, and add the feature to the list in <code>README.md</code>.</p> </li> </ol> <p>Thanks a lot all!</p>"},{"location":"modules.html","title":"Modules","text":"<p>Base classes for API clients.</p> <p>Client for the Belgian DOV (Databank Ondergrond Vlaanderen) API.</p>"},{"location":"modules.html#dovwms.base.WMSClient","title":"<code>WMSClient</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for WMS service clients.</p> Source code in <code>dovwms/base.py</code> <pre><code>class WMSClient(ABC):\n    \"\"\"Abstract base class for WMS service clients.\"\"\"\n\n    def __init__(self, base_url: str, wms_version: str = \"1.3.0\"):\n        \"\"\"Initialize the WMS client.\n\n        The reason for the property and a setter implementation is to allow lazy connection\n        to the WMS service at the point it is needed.\n\n        Arguments:\n            base_url: Base URL of the WMS service\n            wms_version: WMS protocol version to use\n        \"\"\"\n        self.base_url = base_url\n        self.wms_version = wms_version\n        self._wms: Optional[WebMapService] = None\n\n    @property\n    def wms(self) -&gt; WebMapService:\n        \"\"\"Get the WMS connection, establishing it if needed.\"\"\"\n        if self._wms is None:\n            self.connect_wms()\n        return self._wms\n\n    @wms.setter\n    def wms(self, value: WebMapService) -&gt; None:\n        \"\"\"Set the WMS connection.\n\n        The setter allows injecting a mock WMS for testing.\n        \"\"\"\n        self._wms = value\n\n    def connect_wms(self) -&gt; WebMapService:\n        \"\"\"Connect to the WMS service and return the connected WebMapService.\n\n        Returns:\n            The connected WebMapService instance.\n        \"\"\"\n        wms_url = self.base_url if self.base_url.endswith(\"/wms\") else f\"{self.base_url}/wms\"\n        try:\n            self._wms = WebMapService(wms_url, version=self.wms_version)\n            logger.info(\"Connected to WMS service %s (%d layers available)\", wms_url, len(self._wms.contents))\n        except Exception:\n            logger.exception(\"Failed to connect to WMS service at %s\", wms_url)\n        else:\n            return self._wms\n            raise\n\n    def list_wms_layers(self, filter_func: Optional[Callable[[str, str], bool]] = None) -&gt; dict[str, str]:\n        \"\"\"List available WMS layers from the service, optionally filtered.\n\n        Arguments:\n            filter_func: Optional function to filter layers. Takes layer name and title\n                       as arguments and returns bool.\n\n        Returns:\n            Dictionary of layer names and titles\n        \"\"\"\n        layers = {\n            name: layer.title\n            for name, layer in self.wms.contents.items()\n            if filter_func is None or filter_func(name, layer.title)\n        }\n        return layers\n\n    def check_layer_exists(self, layer_name: str) -&gt; bool:\n        \"\"\"Check if a layer exists in the WMS service.\n\n        Arguments:\n            layer_name: Name of the layer to check\n\n        Returns:\n            True if layer exists, False otherwise\n        \"\"\"\n        return layer_name in self.wms.contents\n\n    @abstractmethod\n    def parse_feature_info(self, content: str, **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Parse GetFeatureInfo response content.\n\n        This method should be implemented by subclasses to handle\n        service-specific response formats. Preferably, in these method, each data\n        type (e.g., soil texture, elevation) gets its own parsing logic in a dedicated\n        private method.\n\n        Arguments:\n            content: Raw response content as string\n            **kwargs: Additional parsing parameters\n\n        Returns:\n            Parsed content in appropriate format\n        \"\"\"\n        pass\n</code></pre>"},{"location":"modules.html#dovwms.base.WMSClient.wms","title":"<code>wms</code>  <code>property</code> <code>writable</code>","text":"<p>Get the WMS connection, establishing it if needed.</p>"},{"location":"modules.html#dovwms.base.WMSClient.__init__","title":"<code>__init__(base_url, wms_version='1.3.0')</code>","text":"<p>Initialize the WMS client.</p> <p>The reason for the property and a setter implementation is to allow lazy connection to the WMS service at the point it is needed.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL of the WMS service</p> required <code>wms_version</code> <code>str</code> <p>WMS protocol version to use</p> <code>'1.3.0'</code> Source code in <code>dovwms/base.py</code> <pre><code>def __init__(self, base_url: str, wms_version: str = \"1.3.0\"):\n    \"\"\"Initialize the WMS client.\n\n    The reason for the property and a setter implementation is to allow lazy connection\n    to the WMS service at the point it is needed.\n\n    Arguments:\n        base_url: Base URL of the WMS service\n        wms_version: WMS protocol version to use\n    \"\"\"\n    self.base_url = base_url\n    self.wms_version = wms_version\n    self._wms: Optional[WebMapService] = None\n</code></pre>"},{"location":"modules.html#dovwms.base.WMSClient.check_layer_exists","title":"<code>check_layer_exists(layer_name)</code>","text":"<p>Check if a layer exists in the WMS service.</p> <p>Parameters:</p> Name Type Description Default <code>layer_name</code> <code>str</code> <p>Name of the layer to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if layer exists, False otherwise</p> Source code in <code>dovwms/base.py</code> <pre><code>def check_layer_exists(self, layer_name: str) -&gt; bool:\n    \"\"\"Check if a layer exists in the WMS service.\n\n    Arguments:\n        layer_name: Name of the layer to check\n\n    Returns:\n        True if layer exists, False otherwise\n    \"\"\"\n    return layer_name in self.wms.contents\n</code></pre>"},{"location":"modules.html#dovwms.base.WMSClient.connect_wms","title":"<code>connect_wms()</code>","text":"<p>Connect to the WMS service and return the connected WebMapService.</p> <p>Returns:</p> Type Description <code>WebMapService</code> <p>The connected WebMapService instance.</p> Source code in <code>dovwms/base.py</code> <pre><code>def connect_wms(self) -&gt; WebMapService:\n    \"\"\"Connect to the WMS service and return the connected WebMapService.\n\n    Returns:\n        The connected WebMapService instance.\n    \"\"\"\n    wms_url = self.base_url if self.base_url.endswith(\"/wms\") else f\"{self.base_url}/wms\"\n    try:\n        self._wms = WebMapService(wms_url, version=self.wms_version)\n        logger.info(\"Connected to WMS service %s (%d layers available)\", wms_url, len(self._wms.contents))\n    except Exception:\n        logger.exception(\"Failed to connect to WMS service at %s\", wms_url)\n    else:\n        return self._wms\n        raise\n</code></pre>"},{"location":"modules.html#dovwms.base.WMSClient.list_wms_layers","title":"<code>list_wms_layers(filter_func=None)</code>","text":"<p>List available WMS layers from the service, optionally filtered.</p> <p>Parameters:</p> Name Type Description Default <code>filter_func</code> <code>Optional[Callable[[str, str], bool]]</code> <p>Optional function to filter layers. Takes layer name and title        as arguments and returns bool.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of layer names and titles</p> Source code in <code>dovwms/base.py</code> <pre><code>def list_wms_layers(self, filter_func: Optional[Callable[[str, str], bool]] = None) -&gt; dict[str, str]:\n    \"\"\"List available WMS layers from the service, optionally filtered.\n\n    Arguments:\n        filter_func: Optional function to filter layers. Takes layer name and title\n                   as arguments and returns bool.\n\n    Returns:\n        Dictionary of layer names and titles\n    \"\"\"\n    layers = {\n        name: layer.title\n        for name, layer in self.wms.contents.items()\n        if filter_func is None or filter_func(name, layer.title)\n    }\n    return layers\n</code></pre>"},{"location":"modules.html#dovwms.base.WMSClient.parse_feature_info","title":"<code>parse_feature_info(content, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Parse GetFeatureInfo response content.</p> <p>This method should be implemented by subclasses to handle service-specific response formats. Preferably, in these method, each data type (e.g., soil texture, elevation) gets its own parsing logic in a dedicated private method.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Raw response content as string</p> required <code>**kwargs</code> <code>Any</code> <p>Additional parsing parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Parsed content in appropriate format</p> Source code in <code>dovwms/base.py</code> <pre><code>@abstractmethod\ndef parse_feature_info(self, content: str, **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Parse GetFeatureInfo response content.\n\n    This method should be implemented by subclasses to handle\n    service-specific response formats. Preferably, in these method, each data\n    type (e.g., soil texture, elevation) gets its own parsing logic in a dedicated\n    private method.\n\n    Arguments:\n        content: Raw response content as string\n        **kwargs: Additional parsing parameters\n\n    Returns:\n        Parsed content in appropriate format\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules.html#dovwms.dov.DOVClient","title":"<code>DOVClient</code>","text":"<p>               Bases: <code>WMSClient</code></p> <p>Client for fetching soil data from the Belgian DOV API.</p> Source code in <code>dovwms/dov.py</code> <pre><code>class DOVClient(WMSClient):\n    \"\"\"Client for fetching soil data from the Belgian DOV API.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Lazy-initialize the DOV client.\n\n        Connects to the DOV Geoserver WMS service for accessing soil data\n        and related geological information.\n        \"\"\"\n        super().__init__(base_url=\"https://www.dov.vlaanderen.be/geoserver\")\n\n    def list_wms_layers(self, filter_func: Optional[Callable[[str, str], bool]] = None) -&gt; dict[str, str]:\n        \"\"\"List available WMS layers from the DOV service.\n\n        Arguments:\n            filter_func: Optional function to filter layers. Takes layer name and title\n                     as arguments and returns bool. If None, only soil-related layers\n                     are returned.\n\n        Returns:\n            Dictionary of layer names and titles\n        \"\"\"\n\n        def soil_filter(name: str, title: str) -&gt; bool:\n            if filter_func is not None:\n                return filter_func(name, title)\n            return \"bodem\" in name.lower()\n\n        return super().list_wms_layers(filter_func=soil_filter)\n\n    def parse_feature_info(self, content: str, **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Parse GetFeatureInfo response from DOV WMS.\n\n        The parsing method depends on the content type and query type:\n        - For soil texture: Parses JSON response with layer properties\n        - For other queries: Returns raw content for specific handling\n\n        Arguments:\n            content: Raw response content\n            **kwargs: Additional parameters:\n                - content_type: Expected content type\n                - query_type: Type of query (e.g., 'texture', 'properties')\n\n        Returns:\n            Parsed content in appropriate format\n        \"\"\"\n        content_type = kwargs.get(\"content_type\", \"application/json\")\n        query_type = kwargs.get(\"query_type\", \"properties\")\n\n        if content_type == \"application/json\" and query_type == \"texture\":\n            return self._parse_texture_response(content)\n\n        return {\"content\": content}\n\n    def _parse_texture_response(self, data: Any) -&gt; dict[str, Any]:\n        \"\"\"Parse the WMS GetFeatureInfo response to extract texture fractions.\n\n        Always returns a dictionary with a single key \"layers\" containing a\n        list of layer dictionaries. This makes the parser output stable and\n        lets callers attach additional information (e.g. elevation) to the\n        returned dict without special-casing list vs dict.\n\n        Args:\n            data: data from a WMS GetFeatureInfo response (JSON string)\n\n        Returns:\n            Dict with key \"layers\" mapping to a list of layer dicts. If no\n            features were found, returns {\"layers\": []}.\n        \"\"\"\n        json_data = json.loads(data)\n        features = json_data.get(\"features\", [])\n\n        if not features:\n            return {\"layers\": []}\n\n        properties = [feature.get(\"properties\") for feature in features]\n\n        # create Layer objects for each of the profiles\n        depth_keys = [k for k in properties[0] if not k.endswith(\"_betrouwbaarheid\")]\n\n        # Map Dutch depth notation to layer info\n        depth_mapping = {\n            \"_0_-_10_cm\": (0, 10, \"Layer_0-10cm\"),\n            \"_10_-_30_cm\": (10, 30, \"Layer_10-30cm\"),\n            \"_30_-_60_cm\": (30, 60, \"Layer_30-60cm\"),\n            \"_60_-_100_cm\": (60, 100, \"Layer_60-100cm\"),\n            \"_100_-_150_cm\": (100, 150, \"Layer_100-150cm\"),\n        }\n\n        layers = []\n\n        for depth_key in depth_keys:\n            ci_key = f\"{depth_key}_betrouwbaarheid\"\n\n            # Extract texture percentages and confidence intervals\n            clay_pct = properties[0][depth_key]\n            clay_mtd = {\n                \"source\": \"DOV WMS, bdbstat:fractie_klei_basisdata_bodemkartering\",\n                \"uncertainty\": properties[0][ci_key],\n            }\n            silt_pct = properties[1][depth_key]\n            silt_mtd = {\n                \"source\": \"DOV WMS, bdbstat:fractie_leem_basisdata_bodemkartering\",\n                \"uncertainty\": properties[1][ci_key],\n            }\n            sand_pct = properties[2][depth_key]\n            sand_mtd = {\n                \"source\": \"DOV WMS, bdbstat:fractie_zand_basisdata_bodemkartering\",\n                \"uncertainty\": properties[2][ci_key],\n            }\n\n            # Get depth info\n            top_depth, bottom_depth, layer_name = depth_mapping[depth_key]\n\n            # Create SoilLayer object\n            layer = {\n                \"name\": layer_name,\n                \"layer_top\": top_depth,\n                \"layer_bottom\": bottom_depth,\n                \"sand_content\": sand_pct,\n                \"silt_content\": silt_pct,\n                \"clay_content\": clay_pct,\n                \"metadata\": {\n                    \"sand_content\": sand_mtd,\n                    \"silt_content\": silt_mtd,\n                    \"clay_content\": clay_mtd,\n                },\n            }\n\n            layers.append(layer)\n\n        return {\"layers\": layers}\n\n    def fetch_profile(\n        self, location: Point, fetch_elevation: bool = False, crs: str = \"EPSG:31370\"\n    ) -&gt; Optional[dict[str, Any]]:\n        \"\"\"Fetch soil texture information from the DOV WMS at a specific location.\n\n        This method queries the DOV WMS service for clay, silt, and sand content\n        at different depths at the specified location. The data is used to create\n        a SoilProfile object with appropriate layers.\n\n        Args:\n            location: Point object with x, y coordinates\n            fetch_elevation: Whether to fetch the elevation of the location from Geopunt.\n            crs: Coordinate reference system\n\n        Returns:\n            Dictionary with texture data (\"layers\" key and optional \"elevation\") or None if data not found\n        \"\"\"\n        # Texture layers from DOV bodemanalysie service.\n        wms_layers = [\n            \"bdbstat:fractie_klei_basisdata_bodemkartering\",  # clay\n            \"bdbstat:fractie_leem_basisdata_bodemkartering\",  # silt\n            \"bdbstat:fractie_zand_basisdata_bodemkartering\",  # sand\n        ]\n\n        # Verify layers exist\n        for layer_name in wms_layers:\n            if not self.check_layer_exists(layer_name):\n                logger.warning(\"Layer %s not found\", layer_name)\n                return None\n\n        # Define query area\n        buffer = 0.0001\n        bbox = (location.x - buffer, location.y - buffer, location.x + buffer, location.y + buffer)\n\n        try:\n            # Query texture data\n            response = self.wms.getfeatureinfo(\n                layers=wms_layers,\n                query_layers=wms_layers,\n                srs=crs,\n                bbox=bbox,\n                size=(100, 100),\n                info_format=\"application/json\",\n                xy=(50, 50),  # center pixel\n            )\n\n            result = self.parse_feature_info(response.read(), content_type=\"application/json\", query_type=\"texture\")\n\n            if fetch_elevation:\n                elevation = get_elevation(location, crs)\n                result[\"elevation\"] = elevation\n        except Exception:\n            logger.exception(\"Failed to fetch profile\")\n            return None\n        else:\n            return result\n</code></pre>"},{"location":"modules.html#dovwms.dov.DOVClient.__init__","title":"<code>__init__()</code>","text":"<p>Lazy-initialize the DOV client.</p> <p>Connects to the DOV Geoserver WMS service for accessing soil data and related geological information.</p> Source code in <code>dovwms/dov.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Lazy-initialize the DOV client.\n\n    Connects to the DOV Geoserver WMS service for accessing soil data\n    and related geological information.\n    \"\"\"\n    super().__init__(base_url=\"https://www.dov.vlaanderen.be/geoserver\")\n</code></pre>"},{"location":"modules.html#dovwms.dov.DOVClient.fetch_profile","title":"<code>fetch_profile(location, fetch_elevation=False, crs='EPSG:31370')</code>","text":"<p>Fetch soil texture information from the DOV WMS at a specific location.</p> <p>This method queries the DOV WMS service for clay, silt, and sand content at different depths at the specified location. The data is used to create a SoilProfile object with appropriate layers.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Point</code> <p>Point object with x, y coordinates</p> required <code>fetch_elevation</code> <code>bool</code> <p>Whether to fetch the elevation of the location from Geopunt.</p> <code>False</code> <code>crs</code> <code>str</code> <p>Coordinate reference system</p> <code>'EPSG:31370'</code> <p>Returns:</p> Type Description <code>Optional[dict[str, Any]]</code> <p>Dictionary with texture data (\"layers\" key and optional \"elevation\") or None if data not found</p> Source code in <code>dovwms/dov.py</code> <pre><code>def fetch_profile(\n    self, location: Point, fetch_elevation: bool = False, crs: str = \"EPSG:31370\"\n) -&gt; Optional[dict[str, Any]]:\n    \"\"\"Fetch soil texture information from the DOV WMS at a specific location.\n\n    This method queries the DOV WMS service for clay, silt, and sand content\n    at different depths at the specified location. The data is used to create\n    a SoilProfile object with appropriate layers.\n\n    Args:\n        location: Point object with x, y coordinates\n        fetch_elevation: Whether to fetch the elevation of the location from Geopunt.\n        crs: Coordinate reference system\n\n    Returns:\n        Dictionary with texture data (\"layers\" key and optional \"elevation\") or None if data not found\n    \"\"\"\n    # Texture layers from DOV bodemanalysie service.\n    wms_layers = [\n        \"bdbstat:fractie_klei_basisdata_bodemkartering\",  # clay\n        \"bdbstat:fractie_leem_basisdata_bodemkartering\",  # silt\n        \"bdbstat:fractie_zand_basisdata_bodemkartering\",  # sand\n    ]\n\n    # Verify layers exist\n    for layer_name in wms_layers:\n        if not self.check_layer_exists(layer_name):\n            logger.warning(\"Layer %s not found\", layer_name)\n            return None\n\n    # Define query area\n    buffer = 0.0001\n    bbox = (location.x - buffer, location.y - buffer, location.x + buffer, location.y + buffer)\n\n    try:\n        # Query texture data\n        response = self.wms.getfeatureinfo(\n            layers=wms_layers,\n            query_layers=wms_layers,\n            srs=crs,\n            bbox=bbox,\n            size=(100, 100),\n            info_format=\"application/json\",\n            xy=(50, 50),  # center pixel\n        )\n\n        result = self.parse_feature_info(response.read(), content_type=\"application/json\", query_type=\"texture\")\n\n        if fetch_elevation:\n            elevation = get_elevation(location, crs)\n            result[\"elevation\"] = elevation\n    except Exception:\n        logger.exception(\"Failed to fetch profile\")\n        return None\n    else:\n        return result\n</code></pre>"},{"location":"modules.html#dovwms.dov.DOVClient.list_wms_layers","title":"<code>list_wms_layers(filter_func=None)</code>","text":"<p>List available WMS layers from the DOV service.</p> <p>Parameters:</p> Name Type Description Default <code>filter_func</code> <code>Optional[Callable[[str, str], bool]]</code> <p>Optional function to filter layers. Takes layer name and title      as arguments and returns bool. If None, only soil-related layers      are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of layer names and titles</p> Source code in <code>dovwms/dov.py</code> <pre><code>def list_wms_layers(self, filter_func: Optional[Callable[[str, str], bool]] = None) -&gt; dict[str, str]:\n    \"\"\"List available WMS layers from the DOV service.\n\n    Arguments:\n        filter_func: Optional function to filter layers. Takes layer name and title\n                 as arguments and returns bool. If None, only soil-related layers\n                 are returned.\n\n    Returns:\n        Dictionary of layer names and titles\n    \"\"\"\n\n    def soil_filter(name: str, title: str) -&gt; bool:\n        if filter_func is not None:\n            return filter_func(name, title)\n        return \"bodem\" in name.lower()\n\n    return super().list_wms_layers(filter_func=soil_filter)\n</code></pre>"},{"location":"modules.html#dovwms.dov.DOVClient.parse_feature_info","title":"<code>parse_feature_info(content, **kwargs)</code>","text":"<p>Parse GetFeatureInfo response from DOV WMS.</p> <p>The parsing method depends on the content type and query type: - For soil texture: Parses JSON response with layer properties - For other queries: Returns raw content for specific handling</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Raw response content</p> required <code>**kwargs</code> <code>Any</code> <p>Additional parameters: - content_type: Expected content type - query_type: Type of query (e.g., 'texture', 'properties')</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Parsed content in appropriate format</p> Source code in <code>dovwms/dov.py</code> <pre><code>def parse_feature_info(self, content: str, **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Parse GetFeatureInfo response from DOV WMS.\n\n    The parsing method depends on the content type and query type:\n    - For soil texture: Parses JSON response with layer properties\n    - For other queries: Returns raw content for specific handling\n\n    Arguments:\n        content: Raw response content\n        **kwargs: Additional parameters:\n            - content_type: Expected content type\n            - query_type: Type of query (e.g., 'texture', 'properties')\n\n    Returns:\n        Parsed content in appropriate format\n    \"\"\"\n    content_type = kwargs.get(\"content_type\", \"application/json\")\n    query_type = kwargs.get(\"query_type\", \"properties\")\n\n    if content_type == \"application/json\" and query_type == \"texture\":\n        return self._parse_texture_response(content)\n\n    return {\"content\": content}\n</code></pre>"},{"location":"modules.html#dovwms.dov.get_profile_from_dov","title":"<code>get_profile_from_dov(x, y, crs='EPSG:31370', fetch_elevation=True, profile_name=None)</code>","text":"<p>Convenience function to fetch a soil profile from DOV at given coordinates.</p> <p>This function handles all the necessary client setup and coordinate conversion to get a soil profile from the DOV service. It's a simpler alternative to creating and managing DOV and Geopunt clients manually.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X-coordinate in the specified CRS (default Lambert72)</p> required <code>y</code> <code>float</code> <p>Y-coordinate in the specified CRS (default Lambert72)</p> required <code>profile_name</code> <code>Optional[str]</code> <p>Optional name for the profile. If None, will use coordinates</p> <code>None</code> <code>crs</code> <code>str</code> <p>Coordinate reference system of the input coordinates</p> <code>'EPSG:31370'</code> <code>fetch_elevation</code> <code>bool</code> <p>elevation data</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[dict[str, Any]]</code> <p>SoilProfile object with texture and optional elevation data,</p> <code>Optional[dict[str, Any]]</code> <p>or None if the data couldn't be fetched</p> Example <p>profile = get_profile_from_dov(247172.56, 204590.58) print(f\"Elevation: {profile.elevation:.2f}m\") print(f\"Number of layers: {len(profile.layers)}\")</p> Source code in <code>dovwms/dov.py</code> <pre><code>def get_profile_from_dov(\n    x: float, y: float, crs: str = \"EPSG:31370\", fetch_elevation: bool = True, profile_name: Optional[str] = None\n) -&gt; Optional[dict[str, Any]]:\n    \"\"\"Convenience function to fetch a soil profile from DOV at given coordinates.\n\n    This function handles all the necessary client setup and coordinate conversion\n    to get a soil profile from the DOV service. It's a simpler alternative to\n    creating and managing DOV and Geopunt clients manually.\n\n    Args:\n        x: X-coordinate in the specified CRS (default Lambert72)\n        y: Y-coordinate in the specified CRS (default Lambert72)\n        profile_name: Optional name for the profile. If None, will use coordinates\n        crs: Coordinate reference system of the input coordinates\n        fetch_elevation: elevation data\n\n    Returns:\n        SoilProfile object with texture and optional elevation data,\n        or None if the data couldn't be fetched\n\n    Example:\n        &gt;&gt;&gt; profile = get_profile_from_dov(247172.56, 204590.58)\n        &gt;&gt;&gt; print(f\"Elevation: {profile.elevation:.2f}m\")\n        &gt;&gt;&gt; print(f\"Number of layers: {len(profile.layers)}\")\n    \"\"\"\n    try:\n        # Create location point\n        location = Point(x, y)\n\n        # Use coordinates for profile name if none provided (kept for backward compatibility,\n        # but DOVClient.fetch_profile does not currently accept a profile_name parameter)\n        if profile_name is None:\n            profile_name = f\"Profile_{x:.0f}_{y:.0f}\"\n\n        # Create DOV client\n        client = DOVClient()\n\n        # Fetch profile. Use the public DOVClient API: (location, fetch_elevation, crs)\n        profile = client.fetch_profile(location, fetch_elevation=fetch_elevation, crs=crs)\n    except Exception:\n        logger.exception(\"Failed to get profile from DOV\")\n        return None\n    else:\n        return profile\n        logger.exception(\"Error fetching profile from DOV\")\n        return None\n</code></pre>"},{"location":"modules.html#dovwms.geopunt.GeopuntClient","title":"<code>GeopuntClient</code>","text":"<p>               Bases: <code>WMSClient</code></p> <p>Client for fetching data from the Geopunt API.</p> Source code in <code>dovwms/geopunt.py</code> <pre><code>class GeopuntClient(WMSClient):\n    \"\"\"Client for fetching data from the Geopunt API.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(base_url=\"https://geo.api.vlaanderen.be/DHMV\")\n\n    def parse_feature_info(self, content: str, **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Parse GetFeatureInfo response from Geopunt WMS.\n\n        The parsing method depends on the content type and query type:\n        - For elevation: Parses semicolon-separated response for elevation value\n        - For other queries: Returns raw content for specific handling.\n        - One substantial change.\n\n        Args:\n            content: Raw response content\n            **kwargs: Additional parameters:\n                - content_type: Expected content type\n                - query_type: Type of query (e.g., 'elevation')\n\n        Returns:\n            Dict containing either {'elevation': float or None} or {'content': str}\n        \"\"\"\n        query_type = kwargs.get(\"query_type\", \"elevation\")\n\n        if query_type == \"elevation\":\n            elevation = self._parse_elevation_response(content)\n            return {\"elevation\": elevation}\n\n        return {\"content\": content}\n\n    def _parse_elevation_response(self, content: str) -&gt; Optional[float]:\n        \"\"\"Parse elevation data from GetFeatureInfo response.\n\n        Args:\n            content: Raw response content from WMS GetFeatureInfo\n\n        Returns:\n            Elevation in meters or None if parsing fails\n\n        Note:\n            Response format example:\n            \"@DHMVII_DTM_1m Stretched value;Pixel Value; 32.360001;32.360001;\"\n        \"\"\"\n        try:\n            values = content.strip().split(\";\")\n            if len(values) &gt;= 3:\n                return float(values[2].strip())\n        except (ValueError, IndexError) as e:\n            logger.warning(\"Error parsing elevation data: %s\", e)\n        return None\n\n    def fetch_elevation(\n        self, location: Point, crs: str = \"EPSG:31370\", layer_name: str = \"DHMVII_DTM_1m\"\n    ) -&gt; Optional[dict[str, Any]]:\n        \"\"\"Fetch elevation data from the Geopunt WMS at a specific location.\n\n        Args:\n            location: Point object with x, y coordinates\n            crs: Coordinate reference system\n        Returns:\n            Elevation in meters or None if not found\n        \"\"\"\n        # Layer name for Digital Terrain Model (1m resolution)\n\n        if not self.check_layer_exists(layer_name):\n            try:\n                available = list(self.wms.contents.keys())\n            except Exception:\n                available = []\n            logger.warning(\"Layer %s not found. Available layers: %s\", layer_name, available)\n            return None\n\n        buffer = 0.0001\n        bbox = (location.x - buffer, location.y - buffer, location.x + buffer, location.y + buffer)\n\n        # Image size and center pixel\n        img_width = img_height = 256\n        pixel_x = pixel_y = img_width // 2\n\n        try:\n            # Make GetFeatureInfo request\n            response = self.wms.getfeatureinfo(\n                layers=[layer_name],\n                query_layers=[layer_name],\n                info_format=\"text/plain\",\n                srs=crs,\n                bbox=bbox,\n                size=(img_width, img_height),\n                xy=(pixel_x, pixel_y),\n            )\n\n            # Parse response using the base class method\n            content = response.read().decode(\"utf-8\")\n            elevation = self.parse_feature_info(content, content_type=\"text/plain\", query_type=\"elevation\")\n\n            if elevation is not None:\n                logger.info(\"Fetched elevation from Geopunt API\")\n        except Exception:\n            logger.exception(\"Failed to fetch elevation from Geopunt API\")\n            return None\n        else:\n            return elevation\n</code></pre>"},{"location":"modules.html#dovwms.geopunt.GeopuntClient.fetch_elevation","title":"<code>fetch_elevation(location, crs='EPSG:31370', layer_name='DHMVII_DTM_1m')</code>","text":"<p>Fetch elevation data from the Geopunt WMS at a specific location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Point</code> <p>Point object with x, y coordinates</p> required <code>crs</code> <code>str</code> <p>Coordinate reference system</p> <code>'EPSG:31370'</code> <p>Returns:     Elevation in meters or None if not found</p> Source code in <code>dovwms/geopunt.py</code> <pre><code>def fetch_elevation(\n    self, location: Point, crs: str = \"EPSG:31370\", layer_name: str = \"DHMVII_DTM_1m\"\n) -&gt; Optional[dict[str, Any]]:\n    \"\"\"Fetch elevation data from the Geopunt WMS at a specific location.\n\n    Args:\n        location: Point object with x, y coordinates\n        crs: Coordinate reference system\n    Returns:\n        Elevation in meters or None if not found\n    \"\"\"\n    # Layer name for Digital Terrain Model (1m resolution)\n\n    if not self.check_layer_exists(layer_name):\n        try:\n            available = list(self.wms.contents.keys())\n        except Exception:\n            available = []\n        logger.warning(\"Layer %s not found. Available layers: %s\", layer_name, available)\n        return None\n\n    buffer = 0.0001\n    bbox = (location.x - buffer, location.y - buffer, location.x + buffer, location.y + buffer)\n\n    # Image size and center pixel\n    img_width = img_height = 256\n    pixel_x = pixel_y = img_width // 2\n\n    try:\n        # Make GetFeatureInfo request\n        response = self.wms.getfeatureinfo(\n            layers=[layer_name],\n            query_layers=[layer_name],\n            info_format=\"text/plain\",\n            srs=crs,\n            bbox=bbox,\n            size=(img_width, img_height),\n            xy=(pixel_x, pixel_y),\n        )\n\n        # Parse response using the base class method\n        content = response.read().decode(\"utf-8\")\n        elevation = self.parse_feature_info(content, content_type=\"text/plain\", query_type=\"elevation\")\n\n        if elevation is not None:\n            logger.info(\"Fetched elevation from Geopunt API\")\n    except Exception:\n        logger.exception(\"Failed to fetch elevation from Geopunt API\")\n        return None\n    else:\n        return elevation\n</code></pre>"},{"location":"modules.html#dovwms.geopunt.GeopuntClient.parse_feature_info","title":"<code>parse_feature_info(content, **kwargs)</code>","text":"<p>Parse GetFeatureInfo response from Geopunt WMS.</p> <p>The parsing method depends on the content type and query type: - For elevation: Parses semicolon-separated response for elevation value - For other queries: Returns raw content for specific handling. - One substantial change.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Raw response content</p> required <code>**kwargs</code> <code>Any</code> <p>Additional parameters: - content_type: Expected content type - query_type: Type of query (e.g., 'elevation')</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict containing either {'elevation': float or None} or {'content': str}</p> Source code in <code>dovwms/geopunt.py</code> <pre><code>def parse_feature_info(self, content: str, **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Parse GetFeatureInfo response from Geopunt WMS.\n\n    The parsing method depends on the content type and query type:\n    - For elevation: Parses semicolon-separated response for elevation value\n    - For other queries: Returns raw content for specific handling.\n    - One substantial change.\n\n    Args:\n        content: Raw response content\n        **kwargs: Additional parameters:\n            - content_type: Expected content type\n            - query_type: Type of query (e.g., 'elevation')\n\n    Returns:\n        Dict containing either {'elevation': float or None} or {'content': str}\n    \"\"\"\n    query_type = kwargs.get(\"query_type\", \"elevation\")\n\n    if query_type == \"elevation\":\n        elevation = self._parse_elevation_response(content)\n        return {\"elevation\": elevation}\n\n    return {\"content\": content}\n</code></pre>"},{"location":"modules.html#dovwms.geopunt.get_elevation","title":"<code>get_elevation(location, crs='EPSG:31370', layer_name='DHMVII_DTM_1m')</code>","text":"<p>Convenience wrapper to fetch elevation using the GeopuntClient.</p> <p>This helper creates a GeopuntClient, requests the elevation for the provided location and returns the value. Tests can patch this function to avoid instantiating the client or making network calls.</p> Source code in <code>dovwms/geopunt.py</code> <pre><code>def get_elevation(\n    location: Point, crs: str = \"EPSG:31370\", layer_name: str = \"DHMVII_DTM_1m\"\n) -&gt; Optional[dict[str, Any]]:\n    \"\"\"Convenience wrapper to fetch elevation using the GeopuntClient.\n\n    This helper creates a GeopuntClient, requests the elevation for the\n    provided location and returns the value. Tests can patch this function\n    to avoid instantiating the client or making network calls.\n    \"\"\"\n    client = GeopuntClient()\n    return client.fetch_elevation(location, crs, layer_name)\n</code></pre>"}]}